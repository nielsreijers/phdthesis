\section{Limitations and the cost of using a VM}
\label{sec-evaluation-limitations}
The quantitative evaluation in the previous sections has shown that AOT compilation techniques can reduce the performance overhead of using a VM to within a range that will be acceptable for many applications. However, this is not the only cost associated with using a VM. This section discusses the limitations of CapeVM, and the cost of using a VM compared to native code.

Since CapeVM is based on Darjeeling, we share many of its limitations. Like Darjeeling, CapeVM does not support multidimensional arrays, reflection, 64-bit or floating point data types \cite{Brouwers:2009cj}. In addition, CapeVM drops support for exceptions and threads since they are much harder to implement in an AOT compiler than in an interpreter. As we will argue in Chapter \ref{sec-lessons-from-jvm}, we feel that if the goal is to provide useful, platform independent and safe reprogramming of sensor node with adequate performance, instead of simply porting Java to a sensor node, many of Java's more advanced features, especially those that are expensive to implement, should be replaced by more lightweight alternatives.

Besides these unsupported features, there are other costs to using CapeVM when compared to native code. One of the most important concerns is size. While our optimisations reduce the code size overhead significantly, AOT compiled code is still larger than native C and the VM itself also takes up space. In terms of RAM, the heap adds a 5 byte overhead to each object or array, and we have seen that Java cannot represent complex structures like \mybench{MoteTrack}'s RSSI signature efficiently. For code that only uses a limited number of large objects or arrays like the \mybench{heat detection} benchmark, this overhead will be acceptable, but for code using many tiny objects like \mybench{MoteTrack} this overhead is significant.

In terms of performance, a limitation of lightweight methods is that they don't support recursive function calls. However, we have not found such code in any benchmark, and the limited amount of RAM on a sensor node means recursion would be a bad choice in most cases.

When optimising code for performance, small choices can often have unexpected consequences. We found this to be much more significant when writing Java code for our VM, than when writing the same algorithms in C where \mycode{avr-gcc}'s optimisations often mean two different approaches in C result in similar binary code. An optimising combined compiler and infuser will help a Java developer by doing some of the same optimisations, but there are many examples where the most natural way to solve a problem in Java may not result in the best performance. For example, Suganuma \cite{Suganuma:2000vl} notes that Java code typically results in many small methods and invocations, which can result in a serious performance penalty if they cannot be made lightweight or eliminated by automatic inlining. Allocating many temporary objects hurts performance, while creating them once and reusing them usually results in slightly unnatural code. While this is also true for C, the impact of C function calls and allocating temporary objects on the stack is much smaller.

The next chapter will look at some of these limitations and propose ideas on how to improve them in future sensor node VMs.

