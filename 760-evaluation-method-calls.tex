\section{Method invocation}
%TODO rewrite this section when new simulation data is available
\label{sec-evaluation-method-invocation}
\input{760-tbl-evaluation-method-calls}

In this section we will examine the effect of the lightweight method, compared to inlined code and normal method calls.

Most of our smaller benchmarks consist of only a single method. ProGuard automatically inlines methods only called from a single location, eliminating all method calls in the \mybench{LEC} benchmark. We will examine the effect of lightweight methods using the \mybench{FFT}, \mybench{Heap sort}, and \mybench{CoreMark} benchmarks.
\mybench{FFT} contains a single function, \mycode{fix\_mpy}, which was inlined by the C compiler, so we manually inlined it in the Java version. \mybench{Heap sort} contains a real method call: it consist of two loops, both repeatedly calling the \mycode{siftDown} method, so ProGuard doesn't inline it. Since it is called from two places, and larger than ProGuard's size threshold, it is not automatically inlined. \mybench{CoreMark }is a much more extensive benchmark, and consists of many methods.

Table \ref{tbl-evaluation-method-calls} lists the functions of the \mybench{CoreMark}, \mybench{FFT} and \mybench{heap sort} benchmarks, and the number of times they are called in a single run. Next, we list the way they are implemented in C. \mybench{CoreMark} only defines normal functions, which are inlined by \mycode{avr-gcc} in three cases. \mybench{FFT}'s \mycode{fix\_mpy} function is marked with the \mycode{inline} compiler hint, which was followed by \mycode{avr-gcc}. Finally \mybench{heap sort} uses just one extra function, and a macro to swap two array elements.

The Java base version column shows the way these functions are implemented in the Java versions of our benchmarks. We manually inlined C macros, and the functions that were inlined by the C compiler. The most commonly called methods were transformed to lightweight methods, simply by adding the \mycode{@Lightweight} annotation where possible. For Java versions of the \mycode{compare\_idx} and \mycode{compare\_complex} methods, this was not possible since we do not support lightweight virtual methods.

In the next two columns we vary these choices slightly to examine the effect of our lightweight methods.

For the \mybench{CoreMark }benchmark, we first replace the inlined implementation of the most frequently called method with a lightweight version. \mycode{ee\_isdigit} returns true if a \mycode{char} passed to it is between \mycode{'0'} and \mycode{'9'}. Since this is a very trivial method, we manually coded the lightweight method to use only the stack and no local variables. This slowed down the benchmark by 5\%, adding 170,494 cycles. Since the method is called 3920 times, this corresponds to an overhead of about 44 cycles, which is on the high side for such a small method.

Here we see another overhead from using a lightweight method that's hard to quantify: the boolean result of \mycode{ee\_isdigit} is used to decide an \mycode{if} statement. When we inline the code, the VM can directly branch on the result of the expression \mycode{(c>='0' \&\& c<='9')}, but the lightweight method first has to return a boolean, which is then tested again after the lightweight call returns.

Next, we see what the performance would be without lightweight methods, and all methods, except the manually inlined \mycode{ee\_isdigit}, have to be implemented as normal Java methods. This adds a total of 1,471,174 cycles, making it almost 1.45 times slower than the lightweight methods version. Spread over 2,725 calls, this means the average method invocation added over 540 cycles, which is within the range predicted in Section \ref{sec-optimisations-method-calls}.

The \mybench{FFT} benchmark has a much lower running time than \mybench{CoreMark,} but still does 768 function calls. In the C and normal Java versions these are inlined. When we change \mycode{fix\_mpy} to a normal Java method, it is too large for ProGuard to inline. If we mark it \mycode{@Lightweight} the large number of calls relative to the total running time means the average overhead of over 41 cycles per invocation slows down the benchmark by 18\%. Without lightweight methods, this would be as high as 268\%

Finally, for the \mybench{heap sort} benchmark we normally use a lightweight method for \mycode{siftDown}. While manually inlining it is possible, it is not an attractive option since the \mycode{siftDown} method is much more complex than \mycode{FIX\_MPY} or \mycode{ee\_isdigit}. When we do inline it, we see that the lightweight method adds some overhead compared to the inlined version, but much less than a normal method call would.

In terms of code size, using normal methods take slightly more space than a lightweight method. Listing \ref{lst-comparison-lightweight-and-normal-invocation} showed that the invocation is more complex for normal methods, and in addition the method prologue and epilogue are longer.

The difference between inlining and lightweight methods is less clear. For the smallest of methods, such as \mybench{CoreMark'}s \mycode{ee\_isdigit}, the inlined code is smaller than the call, but the \mybench{heap sort} benchmark shows that inlining larger methods can result in significantly larger code. Since \mycode{siftDown} is called from two places, duplicating it leads to a 11\% increase for the 16-bit version of \mybench{heap sort}. For the 32-bit version, where \mycode{siftDown} is relatively larger, this increases to 27\%.

As these three examples show, using lightweight methods gives us an option in-between a normal method call and inlining. This avoids most of the overhead of a normal method call, and the potential size increase of inlining.


