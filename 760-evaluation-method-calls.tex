\section{Method invocation}
\label{sec-evaluation-method-invocation}
\input{760-tbl-benchmark-methods}

Most of our benchmarks consist of only a single method. The three small functions in the FFT benchmark were inlined by the C compiler, so we manually inlined them in the Java version. Heap sort does contain a real method call: it consist of a main loop, repeatedly calling the \mycode{siftDown} method. CoreMark is a much more extensive benchmark consisting of many methods.

In this section we will examine the effect of the lightweight method calls on these three benchmarks, compared to inlined code and normal method calls.

In Table \ref{tbl-benchmark-methods} we see the most frequently called methods of the CoreMark, FFT and heap sort benchmarks, and the number of times they are called in a single run. Next, we list the way they are implemented in C. CoreMark only defines normal functions, which are inlined by \mycode{avr-gcc} in three cases. FFT contains 3 methods marked with the \mycode{inline} compiler hint, which was followed by \mycode{avr-gcc}. Finally heap sort uses just one extra function, and a macro to swap two array elements.

The Java base version column shows the way these functions are implemented in the Java versions of our benchmarks. We manually inlined C macros, and the smallest functions that were inlined by the C compiler. The most commonly called methods were transformed to lightweight methods, simply by adding the \mycode{@Lightweight} annotation where possible. For Java versions of the \mycode{compare\_idx} and \mycode{compare\_complex} methods, this was not possible since we do not support lightweight virtual methods.

In the next two columns we vary these choices slightly to examine the effect of our lightweight methods.

For the CoreMark benchmark, we first replace the inlined implementation of the most frequently called method with a lightweight version. \mycode{ee\_isdigit} returns true if a \mycode{char} passed to it is between \mycode{'0'} and \mycode{'9'}. Since this is a very trivial method, we manually coded the lightweight method to use only the stack and no local variables. This slowed the benchmark down by 4.5\%, adding 157,782 cycles. Since the method is called 3920 times, this corresponds to an overhead of about 40 cycles, which is on the high side for such a small method.

Here we see another overhead from using a lightweight method that's hard to quantify: the boolean result of \mycode{ee\_isdigit} is used to decide an \mycode{if} statement. When we inline the code, the VM can directly branch on the result of the expression \mycode{(c>='0' \&\& c<='9')}, but the lightweight method first has to return a boolean, which is then tested again after the lightweight call returns.

Next, we see what the performance would be without lightweight methods, and all methods, except the manually inlined \mycode{ee\_isdigit}, have to be implemented as normal Java methods. This adds a total of 1,548,046 cycles, making it almost 1.5 times slower than the lightweight methods version. Spread over 2406 calls, this means the average method invocation added over 643 cycles, which is within the range predicted in Section \ref{sec-optimisations-method-calls}.

The FFT benchmark has a much lower running time than CoreMark, but still does 894 function calls. In the C and normal Java versions these are inlined. When we change them all to normal Java methods, ProGuard will automatically inline the \mycode{SIN8} and \mycode{COS8} methods, adding only a minimal overhead, but the \mycode{FIX\_MPY} method is too large for ProGuard to inline. If we mark it \mycode{@Lightweight} the large number of calls relative to the total running time means the average overhead of over 40 cycles per invocation slows down the benchmark by 45\%. Without lightweight methods, this would be as high as 619\%

Finally, for the heap sort benchmark we normally use a lightweight method for \mycode{siftDown}. In the second version we see that, like in the CoreMark example, the difference between inlining and the lightweight method is small: we only gain 1\% by manual inlining. However, the benchmark runs almost twice as long when we use a normal method call instead of a lightweight method. A significant increase, but less than FFT since heap sort does half as many calls and has a higher total running time to spread the call overhead.

In terms of code size, we can see normal methods take slightly more space than a lightweight method. Listing \ref{lst-comparison-lightweight-and-normal-invocation} showed that the invocation is more complex for normal methods, and in addition the method prologue and epilogue are longer.

The difference between inlining and lightweight methods is less clear. For the smallest of methods, such as CoreMark's \mycode{ee\_isdigit}, the inlined code is smaller than the call, but the heap sort benchmark shows that inlining larger methods can result in significantly larger code.

As these three examples show, using lightweight methods gives us an option in-between a normal method call and inlining. This avoids most of the overhead of a normal method call, and the potential size increase of inlining.
