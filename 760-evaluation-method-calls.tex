\section{Method invocation}
\label{sec-evaluation-method-invocation}
\input{760-tbl-evaluation-method-calls}

In this section we will examine the effect of lightweight method calls, compared to inlined code and normal method calls.

Most of our smaller benchmarks consist of only a single method. ProGuard automatically inlines methods only called from a single location, eliminating all method calls in the \mybench{LEC} benchmark. We will examine the effect of lightweight methods using the \mybench{CoreMark}, \mybench{FFT}, and \mybench{Heap sort} benchmarks.

Table \ref{tbl-evaluation-method-calls} lists the functions of the \mybench{CoreMark}, \mybench{FFT} and \mybench{heap sort} benchmarks, and the number of times they are called in a single run. Next, we list the way they are implemented in C. \mybench{CoreMark} is the most extensive benchmark. It only defines normal functions, which are inlined by \mycode{avr-gcc} in three cases. \mybench{FFT} only contains a single function: \mycode{FIX_MPY}. This function is marked with the \mycode{inline} compiler hint, which was followed by \mycode{avr-gcc}. Finally, \mybench{Heap sort} contains a macro to swap two array elements, and has two loops which both repeatedly call the \mycode{siftDown} function. 

The Java base version column shows the way these functions are implemented in the Java versions of the benchmarks. C macros and the functions that are inlined by the C compiler are manually inlined in the Java version. The other functions are converted to Java methods, two of which were automatically inlined by Proguard in the \mybench{CoreMark} benchmark since they are only called from a single location. In \mybench{heap sort}, the \mycode{siftDown} method is called from two places, and larger than ProGuard's size threshold, so it is not automatically inlined. The most commonly called methods are transformed to lightweight methods, simply by adding the \mycode{@Lightweight} annotation. % where possible. For the Java versions of the \mycode{compare_idx} and \mycode{compare_complex} methods, this was not possible since lightweight virtual methods are not supported.

In the next two columns these choices are varied slightly to examine the effect of lightweight methods. For the \mybench{CoreMark} benchmark, we first replace the inlined implementation of the most frequently called method with a lightweight version. \mycode{ee_isdigit} returns true if a \mycode{char} passed to it is between \mycode{'0'} and \mycode{'9'}. Since this is a very trivial method, we manually wrote the bytecode for this lightweight method to use only the stack and no local variables. This slowed down the benchmark by 6\%, adding 157,648 cycles. Since the method is called 3920 times, this corresponds to an overhead of about 40 cycles per call, which is on the high side for such a small method.

This is due to another overhead from using a lightweight method that's hard to quantify: the boolean result of \mycode{ee_isdigit} is used to decide an \mycode{if} statement. Using inlined code, the VM can directly branch on the result of the expression \mycode{(c>='0' && c<='9')}, but the lightweight method first has to return a boolean, which is then tested after the lightweight call returns.

The last column shows the performance without lightweight methods, when all methods, except the manually inlined \mycode{ee_isdigit} and \mycode{crcu8}, have to be implemented as normal Java methods. This adds a total of 1,149,588 cycles, making it 1.42 times slower than the version using lightweight methods. Spread over 1,825 calls, this means the average method invocation added over 630 cycles, which is within the range predicted in Section \ref{sec-optimisations-method-calls}.

The \mybench{FFT} benchmark has a much lower running time than \mybench{CoreMark,} but still does 768 function calls. In the C and normal Java versions these are inlined. When we change \mycode{FIX_MPY} to a normal Java method, it is too large for ProGuard to inline. Using a handwritten lightweight method, the large number of calls relative to the total running time means the average overhead of over 46 cycles per invocation slows down the benchmark by 20\%. Without lightweight methods, the overhead is 627 per call, slowing down the benchmark by 268\%.

Finally, for the \mybench{heap sort} benchmark we normally use a lightweight method for \mycode{siftDown}. The version where \mycode{siftDown} is inlined shows that the lightweight method call adds some overhead compared to the inlined version, but much less than a normal method call would. However, while manually inlining it is possible, it is not an attractive option since the \mycode{siftDown} method is much more complex than \mycode{FIX_MPY} or \mycode{ee_isdigit}.

In terms of code size, using normal methods take slightly more space than a lightweight method. Listing \ref{lst-comparison-lightweight-and-normal-invocation} showed that the invocation is more complex for normal methods, and in addition the method prologue and epilogue are longer.

The difference between inlining and lightweight methods is less clear. For the smallest of methods, such as \mybench{CoreMark}'s \mycode{ee_isdigit}, the inlined code is slightly smaller than the call, but the \mybench{heap sort} benchmark shows that inlining larger methods can result in significantly larger code. Since \mycode{siftDown} is called from two places, duplicating it leads to a 11\% increase in code size for the 16-bit version of \mybench{heap sort}. For the 32-bit version, where \mycode{siftDown} is relatively larger, this increases to 27\%.

As these three examples show, using lightweight methods gives us an option in between a normal method call and inlining. This avoids most of the overhead of a normal method call, and the potential size increase of inlining.


