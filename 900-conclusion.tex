\chapter{Conclusion}
This dissertation described the MyVM sensor node virtual machine. MyVM extends the state of the art by combining the desirable features of platform independent reprogramming and a safe execution environment with acceptable performance. We evaluated MyVM using a set of benchmarks, including small benchmarks to highlight specific behaviours, and five examples of real sensor node applications.

To come back to the research questions stated in Section \ref{sec-introduction-research-questions}, we can conclude the following:

\begin{enumerate}
	\item
	After identifying the sources of overhead in previous work on ahead-of-time compilers for sensor nodes, MyVM introduced a number of optimisations to reduce the performance overhead by over 80\%, and the code size overhead by 60\%, resulting in an average performance overhead of 105\%, and the code size overhead of 82\% compared to native C.

	The optimisations introduced by MyVM do increase the size of our VM, but the break-even point at which this is compensated for by the smaller code it generates, is well within the range of programme memory typically available on a sensor node.

	The price to pay for platform independence and a safe execution environment comes in three forms. We believe the remaining performance overhead will be acceptable for many applications, but the increase in code size, and the space taken by the VM do limit the size of applications we can load onto a device. In addition, the overhead in memory usage was a problem for a number of benchmarks.

	\item
	MyVM's second contribution is providing a safe execution environment. Compared to native binary code, the higher level of abstraction of MyVM's bytecode allowed us to develop a relatively simple set of safety checks.
	
	This results in a modest overhead in terms of VM size, and the fact that most checks are performed at translation time means the additional overhead for providing safety is limited to a 35\% slowdown and 6\% increase in code size, again relative to native C.

	\item
	Regarding the question of whether Java is a suitable language for a sensor node VM, we can conclude some aspects of it are a good match. An advantage of its simple stack-based instruction set is that it can be implemented in a small VM, and while we showed the stack-based architecture introduces significant overhead, most of this overhead is eliminated by our optimisations.
	
	However, our benchmarks also exposed several problems that ultimately make standard Java a poor choice. Specifically, the lack of support for constant data, and the inefficient use of memory for benchmarks containing many small objects meant some benchmarks could not be ported directly from C to Java. We proposed several improvements, but conclude that more work is necessary to come to a more sensor node specific language and make sensor node VMs truly useful in a wide range of real-world projects.
\end{enumerate}

\input{900-tbl-comparison-to-related-work}

Finally, we conclude by comparing our approach to existing work on both improve sensor node VM performance and safe execution environments in Table \ref{tbl-contribution-comparison}.

Taking unsafe and platform specific native C as a baseline, we first note that existing interpreting sensor node VM's are typically not safe, and suffer from a 1 to 2 orders of magnitude slowdown. The performance overhead was reduced drastically by Ellul's work on Ahead-of-Time compilation, but still a significant overhead remains and this approach increases code size, reducing the size of programmes we can load onto a device.

On the safety side, Safe TinyOS achieves safety with relatively little overhead, but this depends on a trusted host. \emph{T-kernel} and Harbor provide safety independent of the host, but at the cost of a significant increase in code size, or performance overhead respectively. Non of these approaches provide platform independence.

Finally, we see our VM provides both platform independence and safety, at a cost in terms of both code size and performance that is lower than or comparable to previous work.

Coming back to the question of whether a VM is a good way to provide security, we first note that since to the best of our knowledge only two such systems exists, we cannot exclude the possibility that native code approaches could be further optimised to achieve better performance.

However our results show that our approach is on-par with or faster than the two existing native code approaches, and provides platform independence at the same time. We also note that if we require a platform independent way of reprogramming our nodes, making it safe comes at a relatively low extra cost, with our safe VM only 19.9\% slower than the unsafe version.
